// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bid: (where?: BidWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  region: (where?: RegionWhereInput) => Promise<boolean>;
  service: (where?: ServiceWhereInput) => Promise<boolean>;
  specialty: (where?: SpecialtyWhereInput) => Promise<boolean>;
  study: (where?: StudyWhereInput) => Promise<boolean>;
  therapeutic: (where?: TherapeuticWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bid: (where: BidWhereUniqueInput) => BidNullablePromise;
  bids: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bid>;
  bidsConnection: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BidConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  region: (where: RegionWhereUniqueInput) => RegionNullablePromise;
  regions: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Region>;
  regionsConnection: (args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => RegionConnectionPromise;
  service: (where: ServiceWhereUniqueInput) => ServiceNullablePromise;
  services: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Service>;
  servicesConnection: (args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ServiceConnectionPromise;
  specialty: (where: SpecialtyWhereUniqueInput) => SpecialtyNullablePromise;
  specialties: (args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Specialty>;
  specialtiesConnection: (args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SpecialtyConnectionPromise;
  study: (where: StudyWhereUniqueInput) => StudyNullablePromise;
  studies: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Study>;
  studiesConnection: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudyConnectionPromise;
  therapeutic: (
    where: TherapeuticWhereUniqueInput
  ) => TherapeuticNullablePromise;
  therapeutics: (args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Therapeutic>;
  therapeuticsConnection: (args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TherapeuticConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBid: (data: BidCreateInput) => BidPromise;
  updateBid: (args: {
    data: BidUpdateInput;
    where: BidWhereUniqueInput;
  }) => BidPromise;
  updateManyBids: (args: {
    data: BidUpdateManyMutationInput;
    where?: BidWhereInput;
  }) => BatchPayloadPromise;
  upsertBid: (args: {
    where: BidWhereUniqueInput;
    create: BidCreateInput;
    update: BidUpdateInput;
  }) => BidPromise;
  deleteBid: (where: BidWhereUniqueInput) => BidPromise;
  deleteManyBids: (where?: BidWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createRegion: (data: RegionCreateInput) => RegionPromise;
  updateRegion: (args: {
    data: RegionUpdateInput;
    where: RegionWhereUniqueInput;
  }) => RegionPromise;
  updateManyRegions: (args: {
    data: RegionUpdateManyMutationInput;
    where?: RegionWhereInput;
  }) => BatchPayloadPromise;
  upsertRegion: (args: {
    where: RegionWhereUniqueInput;
    create: RegionCreateInput;
    update: RegionUpdateInput;
  }) => RegionPromise;
  deleteRegion: (where: RegionWhereUniqueInput) => RegionPromise;
  deleteManyRegions: (where?: RegionWhereInput) => BatchPayloadPromise;
  createService: (data: ServiceCreateInput) => ServicePromise;
  updateService: (args: {
    data: ServiceUpdateInput;
    where: ServiceWhereUniqueInput;
  }) => ServicePromise;
  updateManyServices: (args: {
    data: ServiceUpdateManyMutationInput;
    where?: ServiceWhereInput;
  }) => BatchPayloadPromise;
  upsertService: (args: {
    where: ServiceWhereUniqueInput;
    create: ServiceCreateInput;
    update: ServiceUpdateInput;
  }) => ServicePromise;
  deleteService: (where: ServiceWhereUniqueInput) => ServicePromise;
  deleteManyServices: (where?: ServiceWhereInput) => BatchPayloadPromise;
  createSpecialty: (data: SpecialtyCreateInput) => SpecialtyPromise;
  updateSpecialty: (args: {
    data: SpecialtyUpdateInput;
    where: SpecialtyWhereUniqueInput;
  }) => SpecialtyPromise;
  updateManySpecialties: (args: {
    data: SpecialtyUpdateManyMutationInput;
    where?: SpecialtyWhereInput;
  }) => BatchPayloadPromise;
  upsertSpecialty: (args: {
    where: SpecialtyWhereUniqueInput;
    create: SpecialtyCreateInput;
    update: SpecialtyUpdateInput;
  }) => SpecialtyPromise;
  deleteSpecialty: (where: SpecialtyWhereUniqueInput) => SpecialtyPromise;
  deleteManySpecialties: (where?: SpecialtyWhereInput) => BatchPayloadPromise;
  createStudy: (data: StudyCreateInput) => StudyPromise;
  updateStudy: (args: {
    data: StudyUpdateInput;
    where: StudyWhereUniqueInput;
  }) => StudyPromise;
  updateManyStudies: (args: {
    data: StudyUpdateManyMutationInput;
    where?: StudyWhereInput;
  }) => BatchPayloadPromise;
  upsertStudy: (args: {
    where: StudyWhereUniqueInput;
    create: StudyCreateInput;
    update: StudyUpdateInput;
  }) => StudyPromise;
  deleteStudy: (where: StudyWhereUniqueInput) => StudyPromise;
  deleteManyStudies: (where?: StudyWhereInput) => BatchPayloadPromise;
  createTherapeutic: (data: TherapeuticCreateInput) => TherapeuticPromise;
  updateTherapeutic: (args: {
    data: TherapeuticUpdateInput;
    where: TherapeuticWhereUniqueInput;
  }) => TherapeuticPromise;
  updateManyTherapeutics: (args: {
    data: TherapeuticUpdateManyMutationInput;
    where?: TherapeuticWhereInput;
  }) => BatchPayloadPromise;
  upsertTherapeutic: (args: {
    where: TherapeuticWhereUniqueInput;
    create: TherapeuticCreateInput;
    update: TherapeuticUpdateInput;
  }) => TherapeuticPromise;
  deleteTherapeutic: (where: TherapeuticWhereUniqueInput) => TherapeuticPromise;
  deleteManyTherapeutics: (
    where?: TherapeuticWhereInput
  ) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bid: (
    where?: BidSubscriptionWhereInput
  ) => BidSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  region: (
    where?: RegionSubscriptionWhereInput
  ) => RegionSubscriptionPayloadSubscription;
  service: (
    where?: ServiceSubscriptionWhereInput
  ) => ServiceSubscriptionPayloadSubscription;
  specialty: (
    where?: SpecialtySubscriptionWhereInput
  ) => SpecialtySubscriptionPayloadSubscription;
  study: (
    where?: StudySubscriptionWhereInput
  ) => StudySubscriptionPayloadSubscription;
  therapeutic: (
    where?: TherapeuticSubscriptionWhereInput
  ) => TherapeuticSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type Phase = "I" | "II" | "III" | "IV";

export type CompanySize = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I";

export type ServiceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "email_ASC"
  | "email_DESC"
  | "logoURL_ASC"
  | "logoURL_DESC"
  | "website_ASC"
  | "website_DESC"
  | "linkedin_ASC"
  | "linkedin_DESC"
  | "overview_ASC"
  | "overview_DESC"
  | "headquarters_ASC"
  | "headquarters_DESC"
  | "companySize_ASC"
  | "companySize_DESC";

export type SpecialtyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type RegionOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type TherapeuticOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type StudyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "area_ASC"
  | "area_DESC"
  | "protocol_number_ASC"
  | "protocol_number_DESC"
  | "title_ASC"
  | "title_DESC"
  | "phase_ASC"
  | "phase_DESC"
  | "services_ASC"
  | "services_DESC"
  | "modified_date_ASC"
  | "modified_date_DESC"
  | "status_ASC"
  | "status_DESC";

export type BidOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bid_amount_ASC"
  | "bid_amount_DESC"
  | "is_approved_ASC"
  | "is_approved_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BidWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ServiceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  specialties_every?: Maybe<SpecialtyWhereInput>;
  specialties_some?: Maybe<SpecialtyWhereInput>;
  specialties_none?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  OR?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
  NOT?: Maybe<ServiceWhereInput[] | ServiceWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  logoURL?: Maybe<String>;
  logoURL_not?: Maybe<String>;
  logoURL_in?: Maybe<String[] | String>;
  logoURL_not_in?: Maybe<String[] | String>;
  logoURL_lt?: Maybe<String>;
  logoURL_lte?: Maybe<String>;
  logoURL_gt?: Maybe<String>;
  logoURL_gte?: Maybe<String>;
  logoURL_contains?: Maybe<String>;
  logoURL_not_contains?: Maybe<String>;
  logoURL_starts_with?: Maybe<String>;
  logoURL_not_starts_with?: Maybe<String>;
  logoURL_ends_with?: Maybe<String>;
  logoURL_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  linkedin?: Maybe<String>;
  linkedin_not?: Maybe<String>;
  linkedin_in?: Maybe<String[] | String>;
  linkedin_not_in?: Maybe<String[] | String>;
  linkedin_lt?: Maybe<String>;
  linkedin_lte?: Maybe<String>;
  linkedin_gt?: Maybe<String>;
  linkedin_gte?: Maybe<String>;
  linkedin_contains?: Maybe<String>;
  linkedin_not_contains?: Maybe<String>;
  linkedin_starts_with?: Maybe<String>;
  linkedin_not_starts_with?: Maybe<String>;
  linkedin_ends_with?: Maybe<String>;
  linkedin_not_ends_with?: Maybe<String>;
  overview?: Maybe<String>;
  overview_not?: Maybe<String>;
  overview_in?: Maybe<String[] | String>;
  overview_not_in?: Maybe<String[] | String>;
  overview_lt?: Maybe<String>;
  overview_lte?: Maybe<String>;
  overview_gt?: Maybe<String>;
  overview_gte?: Maybe<String>;
  overview_contains?: Maybe<String>;
  overview_not_contains?: Maybe<String>;
  overview_starts_with?: Maybe<String>;
  overview_not_starts_with?: Maybe<String>;
  overview_ends_with?: Maybe<String>;
  overview_not_ends_with?: Maybe<String>;
  headquarters?: Maybe<String>;
  headquarters_not?: Maybe<String>;
  headquarters_in?: Maybe<String[] | String>;
  headquarters_not_in?: Maybe<String[] | String>;
  headquarters_lt?: Maybe<String>;
  headquarters_lte?: Maybe<String>;
  headquarters_gt?: Maybe<String>;
  headquarters_gte?: Maybe<String>;
  headquarters_contains?: Maybe<String>;
  headquarters_not_contains?: Maybe<String>;
  headquarters_starts_with?: Maybe<String>;
  headquarters_not_starts_with?: Maybe<String>;
  headquarters_ends_with?: Maybe<String>;
  headquarters_not_ends_with?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  companySize_not?: Maybe<CompanySize>;
  companySize_in?: Maybe<CompanySize[] | CompanySize>;
  companySize_not_in?: Maybe<CompanySize[] | CompanySize>;
  services_every?: Maybe<ServiceWhereInput>;
  services_some?: Maybe<ServiceWhereInput>;
  services_none?: Maybe<ServiceWhereInput>;
  regions_every?: Maybe<RegionWhereInput>;
  regions_some?: Maybe<RegionWhereInput>;
  regions_none?: Maybe<RegionWhereInput>;
  therapeutics_every?: Maybe<TherapeuticWhereInput>;
  therapeutics_some?: Maybe<TherapeuticWhereInput>;
  therapeutics_none?: Maybe<TherapeuticWhereInput>;
  studies_every?: Maybe<StudyWhereInput>;
  studies_some?: Maybe<StudyWhereInput>;
  studies_none?: Maybe<StudyWhereInput>;
  bids_every?: Maybe<BidWhereInput>;
  bids_some?: Maybe<BidWhereInput>;
  bids_none?: Maybe<BidWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface RegionWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  OR?: Maybe<RegionWhereInput[] | RegionWhereInput>;
  NOT?: Maybe<RegionWhereInput[] | RegionWhereInput>;
}

export interface TherapeuticWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  AND?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
  OR?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
  NOT?: Maybe<TherapeuticWhereInput[] | TherapeuticWhereInput>;
}

export interface StudyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  OR?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  NOT?: Maybe<StudyWhereInput[] | StudyWhereInput>;
}

export interface BidWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  study?: Maybe<StudyWhereInput>;
  AND?: Maybe<BidWhereInput[] | BidWhereInput>;
  OR?: Maybe<BidWhereInput[] | BidWhereInput>;
  NOT?: Maybe<BidWhereInput[] | BidWhereInput>;
}

export interface SpecialtyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  companies_every?: Maybe<CompanyWhereInput>;
  companies_some?: Maybe<CompanyWhereInput>;
  companies_none?: Maybe<CompanyWhereInput>;
  services_every?: Maybe<ServiceWhereInput>;
  services_some?: Maybe<ServiceWhereInput>;
  services_none?: Maybe<ServiceWhereInput>;
  sub_specialties_every?: Maybe<SpecialtyWhereInput>;
  sub_specialties_some?: Maybe<SpecialtyWhereInput>;
  sub_specialties_none?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
  OR?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
  NOT?: Maybe<SpecialtyWhereInput[] | SpecialtyWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type RegionWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type ServiceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type SpecialtyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type StudyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type TherapeuticWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BidCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneWithoutBidsInput;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface CompanyCreateOneWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutBidsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
}

export interface CompanyCreatephasesInput {
  set?: Maybe<Phase[] | Phase>;
}

export interface ServiceCreateManyWithoutCompaniesInput {
  create?: Maybe<
    ServiceCreateWithoutCompaniesInput[] | ServiceCreateWithoutCompaniesInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
  specialties?: Maybe<SpecialtyCreateManyWithoutServicesInput>;
}

export interface SpecialtyCreateManyWithoutServicesInput {
  create?: Maybe<
    SpecialtyCreateWithoutServicesInput[] | SpecialtyCreateWithoutServicesInput
  >;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
}

export interface SpecialtyCreateWithoutServicesInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyInput>;
  sub_specialties?: Maybe<SpecialtyCreateManyInput>;
}

export interface CompanyCreateManyInput {
  create?: Maybe<CompanyCreateInput[] | CompanyCreateInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface RegionCreateManyWithoutCompaniesInput {
  create?: Maybe<
    RegionCreateWithoutCompaniesInput[] | RegionCreateWithoutCompaniesInput
  >;
  connect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
}

export interface RegionCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface TherapeuticCreateManyWithoutCompaniesInput {
  create?: Maybe<
    | TherapeuticCreateWithoutCompaniesInput[]
    | TherapeuticCreateWithoutCompaniesInput
  >;
  connect?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
}

export interface TherapeuticCreateWithoutCompaniesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface StudyCreateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
}

export interface StudyCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
}

export interface BidCreateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
}

export interface BidCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface StudyCreateOneInput {
  create?: Maybe<StudyCreateInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
  company: CompanyCreateOneWithoutStudiesInput;
}

export interface CompanyCreateOneWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutStudiesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface SpecialtyCreateManyInput {
  create?: Maybe<SpecialtyCreateInput[] | SpecialtyCreateInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
}

export interface SpecialtyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyInput>;
  services?: Maybe<ServiceCreateManyWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyCreateManyInput>;
}

export interface ServiceCreateManyWithoutSpecialtiesInput {
  create?: Maybe<
    | ServiceCreateWithoutSpecialtiesInput[]
    | ServiceCreateWithoutSpecialtiesInput
  >;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
}

export interface ServiceCreateWithoutSpecialtiesInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutServicesInput>;
}

export interface CompanyCreateManyWithoutServicesInput {
  create?: Maybe<
    CompanyCreateWithoutServicesInput[] | CompanyCreateWithoutServicesInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutServicesInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface BidUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutBidsInput>;
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface CompanyUpdateOneRequiredWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  update?: Maybe<CompanyUpdateWithoutBidsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutBidsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdatephasesInput {
  set?: Maybe<Phase[] | Phase>;
}

export interface ServiceUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    ServiceCreateWithoutCompaniesInput[] | ServiceCreateWithoutCompaniesInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutCompaniesInput[]
    | ServiceUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutCompaniesInput[]
    | ServiceUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  updateMany?: Maybe<
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ServiceUpdateWithWhereUniqueWithoutCompaniesInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutCompaniesDataInput;
}

export interface ServiceUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
  specialties?: Maybe<SpecialtyUpdateManyWithoutServicesInput>;
}

export interface SpecialtyUpdateManyWithoutServicesInput {
  create?: Maybe<
    SpecialtyCreateWithoutServicesInput[] | SpecialtyCreateWithoutServicesInput
  >;
  delete?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  set?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  disconnect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  update?: Maybe<
    | SpecialtyUpdateWithWhereUniqueWithoutServicesInput[]
    | SpecialtyUpdateWithWhereUniqueWithoutServicesInput
  >;
  upsert?: Maybe<
    | SpecialtyUpsertWithWhereUniqueWithoutServicesInput[]
    | SpecialtyUpsertWithWhereUniqueWithoutServicesInput
  >;
  deleteMany?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  updateMany?: Maybe<
    | SpecialtyUpdateManyWithWhereNestedInput[]
    | SpecialtyUpdateManyWithWhereNestedInput
  >;
}

export interface SpecialtyUpdateWithWhereUniqueWithoutServicesInput {
  where: SpecialtyWhereUniqueInput;
  data: SpecialtyUpdateWithoutServicesDataInput;
}

export interface SpecialtyUpdateWithoutServicesDataInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface CompanyUpdateManyInput {
  create?: Maybe<CompanyCreateInput[] | CompanyCreateInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueNestedInput[]
    | CompanyUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueNestedInput[]
    | CompanyUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueNestedInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateDataInput;
}

export interface CompanyUpdateDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface RegionUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    RegionCreateWithoutCompaniesInput[] | RegionCreateWithoutCompaniesInput
  >;
  delete?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  connect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  set?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  disconnect?: Maybe<RegionWhereUniqueInput[] | RegionWhereUniqueInput>;
  update?: Maybe<
    | RegionUpdateWithWhereUniqueWithoutCompaniesInput[]
    | RegionUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | RegionUpsertWithWhereUniqueWithoutCompaniesInput[]
    | RegionUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  updateMany?: Maybe<
    | RegionUpdateManyWithWhereNestedInput[]
    | RegionUpdateManyWithWhereNestedInput
  >;
}

export interface RegionUpdateWithWhereUniqueWithoutCompaniesInput {
  where: RegionWhereUniqueInput;
  data: RegionUpdateWithoutCompaniesDataInput;
}

export interface RegionUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
}

export interface RegionUpsertWithWhereUniqueWithoutCompaniesInput {
  where: RegionWhereUniqueInput;
  update: RegionUpdateWithoutCompaniesDataInput;
  create: RegionCreateWithoutCompaniesInput;
}

export interface RegionScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  OR?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
  NOT?: Maybe<RegionScalarWhereInput[] | RegionScalarWhereInput>;
}

export interface RegionUpdateManyWithWhereNestedInput {
  where: RegionScalarWhereInput;
  data: RegionUpdateManyDataInput;
}

export interface RegionUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface TherapeuticUpdateManyWithoutCompaniesInput {
  create?: Maybe<
    | TherapeuticCreateWithoutCompaniesInput[]
    | TherapeuticCreateWithoutCompaniesInput
  >;
  delete?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  connect?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  set?: Maybe<TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput>;
  disconnect?: Maybe<
    TherapeuticWhereUniqueInput[] | TherapeuticWhereUniqueInput
  >;
  update?: Maybe<
    | TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput[]
    | TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput
  >;
  upsert?: Maybe<
    | TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput[]
    | TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput
  >;
  deleteMany?: Maybe<
    TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput
  >;
  updateMany?: Maybe<
    | TherapeuticUpdateManyWithWhereNestedInput[]
    | TherapeuticUpdateManyWithWhereNestedInput
  >;
}

export interface TherapeuticUpdateWithWhereUniqueWithoutCompaniesInput {
  where: TherapeuticWhereUniqueInput;
  data: TherapeuticUpdateWithoutCompaniesDataInput;
}

export interface TherapeuticUpdateWithoutCompaniesDataInput {
  name?: Maybe<String>;
}

export interface TherapeuticUpsertWithWhereUniqueWithoutCompaniesInput {
  where: TherapeuticWhereUniqueInput;
  update: TherapeuticUpdateWithoutCompaniesDataInput;
  create: TherapeuticCreateWithoutCompaniesInput;
}

export interface TherapeuticScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
  OR?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
  NOT?: Maybe<TherapeuticScalarWhereInput[] | TherapeuticScalarWhereInput>;
}

export interface TherapeuticUpdateManyWithWhereNestedInput {
  where: TherapeuticScalarWhereInput;
  data: TherapeuticUpdateManyDataInput;
}

export interface TherapeuticUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface StudyUpdateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  delete?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  set?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  disconnect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  update?: Maybe<
    | StudyUpdateWithWhereUniqueWithoutCompanyInput[]
    | StudyUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | StudyUpsertWithWhereUniqueWithoutCompanyInput[]
    | StudyUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  updateMany?: Maybe<
    StudyUpdateManyWithWhereNestedInput[] | StudyUpdateManyWithWhereNestedInput
  >;
}

export interface StudyUpdateWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  data: StudyUpdateWithoutCompanyDataInput;
}

export interface StudyUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface StudyUpsertWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  update: StudyUpdateWithoutCompanyDataInput;
  create: StudyCreateWithoutCompanyInput;
}

export interface StudyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  OR?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  NOT?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
}

export interface StudyUpdateManyWithWhereNestedInput {
  where: StudyScalarWhereInput;
  data: StudyUpdateManyDataInput;
}

export interface StudyUpdateManyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface BidUpdateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  delete?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  set?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  disconnect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  update?: Maybe<
    | BidUpdateWithWhereUniqueWithoutCompanyInput[]
    | BidUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | BidUpsertWithWhereUniqueWithoutCompanyInput[]
    | BidUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  updateMany?: Maybe<
    BidUpdateManyWithWhereNestedInput[] | BidUpdateManyWithWhereNestedInput
  >;
}

export interface BidUpdateWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  data: BidUpdateWithoutCompanyDataInput;
}

export interface BidUpdateWithoutCompanyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface StudyUpdateOneRequiredInput {
  create?: Maybe<StudyCreateInput>;
  update?: Maybe<StudyUpdateDataInput>;
  upsert?: Maybe<StudyUpsertNestedInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyUpdateDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface CompanyUpdateOneRequiredWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  update?: Maybe<CompanyUpdateWithoutStudiesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutStudiesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithoutStudiesInput {
  update: CompanyUpdateWithoutStudiesDataInput;
  create: CompanyCreateWithoutStudiesInput;
}

export interface StudyUpsertNestedInput {
  update: StudyUpdateDataInput;
  create: StudyCreateInput;
}

export interface BidUpsertWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  update: BidUpdateWithoutCompanyDataInput;
  create: BidCreateWithoutCompanyInput;
}

export interface BidScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  AND?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  OR?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  NOT?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
}

export interface BidUpdateManyWithWhereNestedInput {
  where: BidScalarWhereInput;
  data: BidUpdateManyDataInput;
}

export interface BidUpdateManyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface CompanyUpsertWithWhereUniqueNestedInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateDataInput;
  create: CompanyCreateInput;
}

export interface CompanyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  logoURL?: Maybe<String>;
  logoURL_not?: Maybe<String>;
  logoURL_in?: Maybe<String[] | String>;
  logoURL_not_in?: Maybe<String[] | String>;
  logoURL_lt?: Maybe<String>;
  logoURL_lte?: Maybe<String>;
  logoURL_gt?: Maybe<String>;
  logoURL_gte?: Maybe<String>;
  logoURL_contains?: Maybe<String>;
  logoURL_not_contains?: Maybe<String>;
  logoURL_starts_with?: Maybe<String>;
  logoURL_not_starts_with?: Maybe<String>;
  logoURL_ends_with?: Maybe<String>;
  logoURL_not_ends_with?: Maybe<String>;
  website?: Maybe<String>;
  website_not?: Maybe<String>;
  website_in?: Maybe<String[] | String>;
  website_not_in?: Maybe<String[] | String>;
  website_lt?: Maybe<String>;
  website_lte?: Maybe<String>;
  website_gt?: Maybe<String>;
  website_gte?: Maybe<String>;
  website_contains?: Maybe<String>;
  website_not_contains?: Maybe<String>;
  website_starts_with?: Maybe<String>;
  website_not_starts_with?: Maybe<String>;
  website_ends_with?: Maybe<String>;
  website_not_ends_with?: Maybe<String>;
  linkedin?: Maybe<String>;
  linkedin_not?: Maybe<String>;
  linkedin_in?: Maybe<String[] | String>;
  linkedin_not_in?: Maybe<String[] | String>;
  linkedin_lt?: Maybe<String>;
  linkedin_lte?: Maybe<String>;
  linkedin_gt?: Maybe<String>;
  linkedin_gte?: Maybe<String>;
  linkedin_contains?: Maybe<String>;
  linkedin_not_contains?: Maybe<String>;
  linkedin_starts_with?: Maybe<String>;
  linkedin_not_starts_with?: Maybe<String>;
  linkedin_ends_with?: Maybe<String>;
  linkedin_not_ends_with?: Maybe<String>;
  overview?: Maybe<String>;
  overview_not?: Maybe<String>;
  overview_in?: Maybe<String[] | String>;
  overview_not_in?: Maybe<String[] | String>;
  overview_lt?: Maybe<String>;
  overview_lte?: Maybe<String>;
  overview_gt?: Maybe<String>;
  overview_gte?: Maybe<String>;
  overview_contains?: Maybe<String>;
  overview_not_contains?: Maybe<String>;
  overview_starts_with?: Maybe<String>;
  overview_not_starts_with?: Maybe<String>;
  overview_ends_with?: Maybe<String>;
  overview_not_ends_with?: Maybe<String>;
  headquarters?: Maybe<String>;
  headquarters_not?: Maybe<String>;
  headquarters_in?: Maybe<String[] | String>;
  headquarters_not_in?: Maybe<String[] | String>;
  headquarters_lt?: Maybe<String>;
  headquarters_lte?: Maybe<String>;
  headquarters_gt?: Maybe<String>;
  headquarters_gte?: Maybe<String>;
  headquarters_contains?: Maybe<String>;
  headquarters_not_contains?: Maybe<String>;
  headquarters_starts_with?: Maybe<String>;
  headquarters_not_starts_with?: Maybe<String>;
  headquarters_ends_with?: Maybe<String>;
  headquarters_not_ends_with?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  companySize_not?: Maybe<CompanySize>;
  companySize_in?: Maybe<CompanySize[] | CompanySize>;
  companySize_not_in?: Maybe<CompanySize[] | CompanySize>;
  AND?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  OR?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  NOT?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
}

export interface CompanyUpdateManyWithWhereNestedInput {
  where: CompanyScalarWhereInput;
  data: CompanyUpdateManyDataInput;
}

export interface CompanyUpdateManyDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
}

export interface SpecialtyUpdateManyInput {
  create?: Maybe<SpecialtyCreateInput[] | SpecialtyCreateInput>;
  update?: Maybe<
    | SpecialtyUpdateWithWhereUniqueNestedInput[]
    | SpecialtyUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | SpecialtyUpsertWithWhereUniqueNestedInput[]
    | SpecialtyUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  connect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  set?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  disconnect?: Maybe<SpecialtyWhereUniqueInput[] | SpecialtyWhereUniqueInput>;
  deleteMany?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  updateMany?: Maybe<
    | SpecialtyUpdateManyWithWhereNestedInput[]
    | SpecialtyUpdateManyWithWhereNestedInput
  >;
}

export interface SpecialtyUpdateWithWhereUniqueNestedInput {
  where: SpecialtyWhereUniqueInput;
  data: SpecialtyUpdateDataInput;
}

export interface SpecialtyUpdateDataInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyInput>;
  services?: Maybe<ServiceUpdateManyWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface ServiceUpdateManyWithoutSpecialtiesInput {
  create?: Maybe<
    | ServiceCreateWithoutSpecialtiesInput[]
    | ServiceCreateWithoutSpecialtiesInput
  >;
  delete?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  connect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  set?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  disconnect?: Maybe<ServiceWhereUniqueInput[] | ServiceWhereUniqueInput>;
  update?: Maybe<
    | ServiceUpdateWithWhereUniqueWithoutSpecialtiesInput[]
    | ServiceUpdateWithWhereUniqueWithoutSpecialtiesInput
  >;
  upsert?: Maybe<
    | ServiceUpsertWithWhereUniqueWithoutSpecialtiesInput[]
    | ServiceUpsertWithWhereUniqueWithoutSpecialtiesInput
  >;
  deleteMany?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  updateMany?: Maybe<
    | ServiceUpdateManyWithWhereNestedInput[]
    | ServiceUpdateManyWithWhereNestedInput
  >;
}

export interface ServiceUpdateWithWhereUniqueWithoutSpecialtiesInput {
  where: ServiceWhereUniqueInput;
  data: ServiceUpdateWithoutSpecialtiesDataInput;
}

export interface ServiceUpdateWithoutSpecialtiesDataInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutServicesInput>;
}

export interface CompanyUpdateManyWithoutServicesInput {
  create?: Maybe<
    CompanyCreateWithoutServicesInput[] | CompanyCreateWithoutServicesInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutServicesInput[]
    | CompanyUpdateWithWhereUniqueWithoutServicesInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutServicesInput[]
    | CompanyUpsertWithWhereUniqueWithoutServicesInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutServicesInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutServicesDataInput;
}

export interface CompanyUpdateWithoutServicesDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutServicesInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutServicesDataInput;
  create: CompanyCreateWithoutServicesInput;
}

export interface ServiceUpsertWithWhereUniqueWithoutSpecialtiesInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutSpecialtiesDataInput;
  create: ServiceCreateWithoutSpecialtiesInput;
}

export interface ServiceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  OR?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
  NOT?: Maybe<ServiceScalarWhereInput[] | ServiceScalarWhereInput>;
}

export interface ServiceUpdateManyWithWhereNestedInput {
  where: ServiceScalarWhereInput;
  data: ServiceUpdateManyDataInput;
}

export interface ServiceUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface SpecialtyUpsertWithWhereUniqueNestedInput {
  where: SpecialtyWhereUniqueInput;
  update: SpecialtyUpdateDataInput;
  create: SpecialtyCreateInput;
}

export interface SpecialtyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  OR?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
  NOT?: Maybe<SpecialtyScalarWhereInput[] | SpecialtyScalarWhereInput>;
}

export interface SpecialtyUpdateManyWithWhereNestedInput {
  where: SpecialtyScalarWhereInput;
  data: SpecialtyUpdateManyDataInput;
}

export interface SpecialtyUpdateManyDataInput {
  name?: Maybe<String>;
}

export interface SpecialtyUpsertWithWhereUniqueWithoutServicesInput {
  where: SpecialtyWhereUniqueInput;
  update: SpecialtyUpdateWithoutServicesDataInput;
  create: SpecialtyCreateWithoutServicesInput;
}

export interface ServiceUpsertWithWhereUniqueWithoutCompaniesInput {
  where: ServiceWhereUniqueInput;
  update: ServiceUpdateWithoutCompaniesDataInput;
  create: ServiceCreateWithoutCompaniesInput;
}

export interface CompanyUpsertWithoutBidsInput {
  update: CompanyUpdateWithoutBidsDataInput;
  create: CompanyCreateWithoutBidsInput;
}

export interface BidUpdateManyMutationInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
}

export interface RegionCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutRegionsInput>;
}

export interface CompanyCreateManyWithoutRegionsInput {
  create?: Maybe<
    CompanyCreateWithoutRegionsInput[] | CompanyCreateWithoutRegionsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutRegionsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface RegionUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutRegionsInput>;
}

export interface CompanyUpdateManyWithoutRegionsInput {
  create?: Maybe<
    CompanyCreateWithoutRegionsInput[] | CompanyCreateWithoutRegionsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutRegionsInput[]
    | CompanyUpdateWithWhereUniqueWithoutRegionsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutRegionsInput[]
    | CompanyUpsertWithWhereUniqueWithoutRegionsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutRegionsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutRegionsDataInput;
}

export interface CompanyUpdateWithoutRegionsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  therapeutics?: Maybe<TherapeuticUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutRegionsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutRegionsDataInput;
  create: CompanyCreateWithoutRegionsInput;
}

export interface RegionUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface ServiceCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutServicesInput>;
  specialties?: Maybe<SpecialtyCreateManyWithoutServicesInput>;
}

export interface ServiceUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutServicesInput>;
  specialties?: Maybe<SpecialtyUpdateManyWithoutServicesInput>;
}

export interface ServiceUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface SpecialtyUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyInput>;
  services?: Maybe<ServiceUpdateManyWithoutSpecialtiesInput>;
  sub_specialties?: Maybe<SpecialtyUpdateManyInput>;
}

export interface SpecialtyUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StudyUpdateInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface StudyUpdateManyMutationInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface TherapeuticCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  companies?: Maybe<CompanyCreateManyWithoutTherapeuticsInput>;
}

export interface CompanyCreateManyWithoutTherapeuticsInput {
  create?: Maybe<
    | CompanyCreateWithoutTherapeuticsInput[]
    | CompanyCreateWithoutTherapeuticsInput
  >;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutTherapeuticsInput {
  id?: Maybe<ID_Input>;
  name: String;
  email?: Maybe<String>;
  phases?: Maybe<CompanyCreatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceCreateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionCreateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface TherapeuticUpdateInput {
  name?: Maybe<String>;
  companies?: Maybe<CompanyUpdateManyWithoutTherapeuticsInput>;
}

export interface CompanyUpdateManyWithoutTherapeuticsInput {
  create?: Maybe<
    | CompanyCreateWithoutTherapeuticsInput[]
    | CompanyCreateWithoutTherapeuticsInput
  >;
  delete?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  connect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  set?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  disconnect?: Maybe<CompanyWhereUniqueInput[] | CompanyWhereUniqueInput>;
  update?: Maybe<
    | CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput[]
    | CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput
  >;
  upsert?: Maybe<
    | CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput[]
    | CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput
  >;
  deleteMany?: Maybe<CompanyScalarWhereInput[] | CompanyScalarWhereInput>;
  updateMany?: Maybe<
    | CompanyUpdateManyWithWhereNestedInput[]
    | CompanyUpdateManyWithWhereNestedInput
  >;
}

export interface CompanyUpdateWithWhereUniqueWithoutTherapeuticsInput {
  where: CompanyWhereUniqueInput;
  data: CompanyUpdateWithoutTherapeuticsDataInput;
}

export interface CompanyUpdateWithoutTherapeuticsDataInput {
  name?: Maybe<String>;
  email?: Maybe<String>;
  phases?: Maybe<CompanyUpdatephasesInput>;
  logoURL?: Maybe<String>;
  website?: Maybe<String>;
  linkedin?: Maybe<String>;
  overview?: Maybe<String>;
  headquarters?: Maybe<String>;
  companySize?: Maybe<CompanySize>;
  services?: Maybe<ServiceUpdateManyWithoutCompaniesInput>;
  regions?: Maybe<RegionUpdateManyWithoutCompaniesInput>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpsertWithWhereUniqueWithoutTherapeuticsInput {
  where: CompanyWhereUniqueInput;
  update: CompanyUpdateWithoutTherapeuticsDataInput;
  create: CompanyCreateWithoutTherapeuticsInput;
}

export interface TherapeuticUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface BidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BidWhereInput>;
  AND?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  OR?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  NOT?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface RegionSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<RegionWhereInput>;
  AND?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  OR?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
  NOT?: Maybe<RegionSubscriptionWhereInput[] | RegionSubscriptionWhereInput>;
}

export interface ServiceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ServiceWhereInput>;
  AND?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  OR?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
  NOT?: Maybe<ServiceSubscriptionWhereInput[] | ServiceSubscriptionWhereInput>;
}

export interface SpecialtySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SpecialtyWhereInput>;
  AND?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
  OR?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
  NOT?: Maybe<
    SpecialtySubscriptionWhereInput[] | SpecialtySubscriptionWhereInput
  >;
}

export interface StudySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudyWhereInput>;
  AND?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  OR?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  NOT?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
}

export interface TherapeuticSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TherapeuticWhereInput>;
  AND?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
  OR?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
  NOT?: Maybe<
    TherapeuticSubscriptionWhereInput[] | TherapeuticSubscriptionWhereInput
  >;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Bid {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPromise extends Promise<Bid>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface BidSubscription
  extends Promise<AsyncIterator<Bid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
  study: <T = StudySubscription>() => T;
}

export interface BidNullablePromise extends Promise<Bid | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface Company {
  id: ID_Output;
  name: String;
  email?: String;
  phases: Phase[];
  logoURL?: String;
  website?: String;
  linkedin?: String;
  overview?: String;
  headquarters?: String;
  companySize?: CompanySize;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = FragmentableArray<Region>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = FragmentableArray<Therapeutic>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phases: () => Promise<AsyncIterator<Phase[]>>;
  logoURL: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  overview: () => Promise<AsyncIterator<String>>;
  headquarters: () => Promise<AsyncIterator<String>>;
  companySize: () => Promise<AsyncIterator<CompanySize>>;
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = Promise<AsyncIterator<RegionSubscription>>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = Promise<AsyncIterator<TherapeuticSubscription>>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = Promise<AsyncIterator<StudySubscription>>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = Promise<AsyncIterator<BidSubscription>>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  regions: <T = FragmentableArray<Region>>(args?: {
    where?: RegionWhereInput;
    orderBy?: RegionOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  therapeutics: <T = FragmentableArray<Therapeutic>>(args?: {
    where?: TherapeuticWhereInput;
    orderBy?: TherapeuticOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Service {
  id: ID_Output;
  name: String;
}

export interface ServicePromise extends Promise<Service>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceSubscription
  extends Promise<AsyncIterator<Service>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  specialties: <T = Promise<AsyncIterator<SpecialtySubscription>>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ServiceNullablePromise
  extends Promise<Service | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Specialty {
  id: ID_Output;
  name: String;
}

export interface SpecialtyPromise extends Promise<Specialty>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sub_specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpecialtySubscription
  extends Promise<AsyncIterator<Specialty>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  services: <T = Promise<AsyncIterator<ServiceSubscription>>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sub_specialties: <T = Promise<AsyncIterator<SpecialtySubscription>>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SpecialtyNullablePromise
  extends Promise<Specialty | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  services: <T = FragmentableArray<Service>>(args?: {
    where?: ServiceWhereInput;
    orderBy?: ServiceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  sub_specialties: <T = FragmentableArray<Specialty>>(args?: {
    where?: SpecialtyWhereInput;
    orderBy?: SpecialtyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Region {
  id: ID_Output;
  name: String;
}

export interface RegionPromise extends Promise<Region>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionSubscription
  extends Promise<AsyncIterator<Region>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface RegionNullablePromise
  extends Promise<Region | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Therapeutic {
  id: ID_Output;
  name: String;
}

export interface TherapeuticPromise extends Promise<Therapeutic>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TherapeuticSubscription
  extends Promise<AsyncIterator<Therapeutic>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  companies: <T = Promise<AsyncIterator<CompanySubscription>>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TherapeuticNullablePromise
  extends Promise<Therapeutic | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  companies: <T = FragmentableArray<Company>>(args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Study {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPromise extends Promise<Study>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface StudySubscription
  extends Promise<AsyncIterator<Study>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
}

export interface StudyNullablePromise
  extends Promise<Study | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface BidConnection {
  pageInfo: PageInfo;
  edges: BidEdge[];
}

export interface BidConnectionPromise
  extends Promise<BidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BidEdge>>() => T;
  aggregate: <T = AggregateBidPromise>() => T;
}

export interface BidConnectionSubscription
  extends Promise<AsyncIterator<BidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBidSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BidEdge {
  node: Bid;
  cursor: String;
}

export interface BidEdgePromise extends Promise<BidEdge>, Fragmentable {
  node: <T = BidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BidEdgeSubscription
  extends Promise<AsyncIterator<BidEdge>>,
    Fragmentable {
  node: <T = BidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBid {
  count: Int;
}

export interface AggregateBidPromise
  extends Promise<AggregateBid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBidSubscription
  extends Promise<AsyncIterator<AggregateBid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface RegionConnection {
  pageInfo: PageInfo;
  edges: RegionEdge[];
}

export interface RegionConnectionPromise
  extends Promise<RegionConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<RegionEdge>>() => T;
  aggregate: <T = AggregateRegionPromise>() => T;
}

export interface RegionConnectionSubscription
  extends Promise<AsyncIterator<RegionConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<RegionEdgeSubscription>>>() => T;
  aggregate: <T = AggregateRegionSubscription>() => T;
}

export interface RegionEdge {
  node: Region;
  cursor: String;
}

export interface RegionEdgePromise extends Promise<RegionEdge>, Fragmentable {
  node: <T = RegionPromise>() => T;
  cursor: () => Promise<String>;
}

export interface RegionEdgeSubscription
  extends Promise<AsyncIterator<RegionEdge>>,
    Fragmentable {
  node: <T = RegionSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateRegion {
  count: Int;
}

export interface AggregateRegionPromise
  extends Promise<AggregateRegion>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateRegionSubscription
  extends Promise<AsyncIterator<AggregateRegion>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ServiceConnection {
  pageInfo: PageInfo;
  edges: ServiceEdge[];
}

export interface ServiceConnectionPromise
  extends Promise<ServiceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ServiceEdge>>() => T;
  aggregate: <T = AggregateServicePromise>() => T;
}

export interface ServiceConnectionSubscription
  extends Promise<AsyncIterator<ServiceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ServiceEdgeSubscription>>>() => T;
  aggregate: <T = AggregateServiceSubscription>() => T;
}

export interface ServiceEdge {
  node: Service;
  cursor: String;
}

export interface ServiceEdgePromise extends Promise<ServiceEdge>, Fragmentable {
  node: <T = ServicePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ServiceEdgeSubscription
  extends Promise<AsyncIterator<ServiceEdge>>,
    Fragmentable {
  node: <T = ServiceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateService {
  count: Int;
}

export interface AggregateServicePromise
  extends Promise<AggregateService>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateServiceSubscription
  extends Promise<AsyncIterator<AggregateService>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SpecialtyConnection {
  pageInfo: PageInfo;
  edges: SpecialtyEdge[];
}

export interface SpecialtyConnectionPromise
  extends Promise<SpecialtyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SpecialtyEdge>>() => T;
  aggregate: <T = AggregateSpecialtyPromise>() => T;
}

export interface SpecialtyConnectionSubscription
  extends Promise<AsyncIterator<SpecialtyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SpecialtyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSpecialtySubscription>() => T;
}

export interface SpecialtyEdge {
  node: Specialty;
  cursor: String;
}

export interface SpecialtyEdgePromise
  extends Promise<SpecialtyEdge>,
    Fragmentable {
  node: <T = SpecialtyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SpecialtyEdgeSubscription
  extends Promise<AsyncIterator<SpecialtyEdge>>,
    Fragmentable {
  node: <T = SpecialtySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSpecialty {
  count: Int;
}

export interface AggregateSpecialtyPromise
  extends Promise<AggregateSpecialty>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSpecialtySubscription
  extends Promise<AsyncIterator<AggregateSpecialty>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudyConnection {
  pageInfo: PageInfo;
  edges: StudyEdge[];
}

export interface StudyConnectionPromise
  extends Promise<StudyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudyEdge>>() => T;
  aggregate: <T = AggregateStudyPromise>() => T;
}

export interface StudyConnectionSubscription
  extends Promise<AsyncIterator<StudyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudySubscription>() => T;
}

export interface StudyEdge {
  node: Study;
  cursor: String;
}

export interface StudyEdgePromise extends Promise<StudyEdge>, Fragmentable {
  node: <T = StudyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudyEdgeSubscription
  extends Promise<AsyncIterator<StudyEdge>>,
    Fragmentable {
  node: <T = StudySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudy {
  count: Int;
}

export interface AggregateStudyPromise
  extends Promise<AggregateStudy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudySubscription
  extends Promise<AsyncIterator<AggregateStudy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TherapeuticConnection {
  pageInfo: PageInfo;
  edges: TherapeuticEdge[];
}

export interface TherapeuticConnectionPromise
  extends Promise<TherapeuticConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TherapeuticEdge>>() => T;
  aggregate: <T = AggregateTherapeuticPromise>() => T;
}

export interface TherapeuticConnectionSubscription
  extends Promise<AsyncIterator<TherapeuticConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TherapeuticEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTherapeuticSubscription>() => T;
}

export interface TherapeuticEdge {
  node: Therapeutic;
  cursor: String;
}

export interface TherapeuticEdgePromise
  extends Promise<TherapeuticEdge>,
    Fragmentable {
  node: <T = TherapeuticPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TherapeuticEdgeSubscription
  extends Promise<AsyncIterator<TherapeuticEdge>>,
    Fragmentable {
  node: <T = TherapeuticSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateTherapeutic {
  count: Int;
}

export interface AggregateTherapeuticPromise
  extends Promise<AggregateTherapeutic>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTherapeuticSubscription
  extends Promise<AsyncIterator<AggregateTherapeutic>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BidSubscriptionPayload {
  mutation: MutationType;
  node: Bid;
  updatedFields: String[];
  previousValues: BidPreviousValues;
}

export interface BidSubscriptionPayloadPromise
  extends Promise<BidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BidPreviousValuesPromise>() => T;
}

export interface BidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BidPreviousValuesSubscription>() => T;
}

export interface BidPreviousValues {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPreviousValuesPromise
  extends Promise<BidPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
}

export interface BidPreviousValuesSubscription
  extends Promise<AsyncIterator<BidPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
  email?: String;
  phases: Phase[];
  logoURL?: String;
  website?: String;
  linkedin?: String;
  overview?: String;
  headquarters?: String;
  companySize?: CompanySize;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  email: () => Promise<String>;
  phases: () => Promise<Phase[]>;
  logoURL: () => Promise<String>;
  website: () => Promise<String>;
  linkedin: () => Promise<String>;
  overview: () => Promise<String>;
  headquarters: () => Promise<String>;
  companySize: () => Promise<CompanySize>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  phases: () => Promise<AsyncIterator<Phase[]>>;
  logoURL: () => Promise<AsyncIterator<String>>;
  website: () => Promise<AsyncIterator<String>>;
  linkedin: () => Promise<AsyncIterator<String>>;
  overview: () => Promise<AsyncIterator<String>>;
  headquarters: () => Promise<AsyncIterator<String>>;
  companySize: () => Promise<AsyncIterator<CompanySize>>;
}

export interface RegionSubscriptionPayload {
  mutation: MutationType;
  node: Region;
  updatedFields: String[];
  previousValues: RegionPreviousValues;
}

export interface RegionSubscriptionPayloadPromise
  extends Promise<RegionSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = RegionPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = RegionPreviousValuesPromise>() => T;
}

export interface RegionSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<RegionSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = RegionSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = RegionPreviousValuesSubscription>() => T;
}

export interface RegionPreviousValues {
  id: ID_Output;
  name: String;
}

export interface RegionPreviousValuesPromise
  extends Promise<RegionPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface RegionPreviousValuesSubscription
  extends Promise<AsyncIterator<RegionPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ServiceSubscriptionPayload {
  mutation: MutationType;
  node: Service;
  updatedFields: String[];
  previousValues: ServicePreviousValues;
}

export interface ServiceSubscriptionPayloadPromise
  extends Promise<ServiceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ServicePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ServicePreviousValuesPromise>() => T;
}

export interface ServiceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ServiceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ServiceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ServicePreviousValuesSubscription>() => T;
}

export interface ServicePreviousValues {
  id: ID_Output;
  name: String;
}

export interface ServicePreviousValuesPromise
  extends Promise<ServicePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface ServicePreviousValuesSubscription
  extends Promise<AsyncIterator<ServicePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface SpecialtySubscriptionPayload {
  mutation: MutationType;
  node: Specialty;
  updatedFields: String[];
  previousValues: SpecialtyPreviousValues;
}

export interface SpecialtySubscriptionPayloadPromise
  extends Promise<SpecialtySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SpecialtyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SpecialtyPreviousValuesPromise>() => T;
}

export interface SpecialtySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SpecialtySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SpecialtySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SpecialtyPreviousValuesSubscription>() => T;
}

export interface SpecialtyPreviousValues {
  id: ID_Output;
  name: String;
}

export interface SpecialtyPreviousValuesPromise
  extends Promise<SpecialtyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface SpecialtyPreviousValuesSubscription
  extends Promise<AsyncIterator<SpecialtyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StudySubscriptionPayload {
  mutation: MutationType;
  node: Study;
  updatedFields: String[];
  previousValues: StudyPreviousValues;
}

export interface StudySubscriptionPayloadPromise
  extends Promise<StudySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudyPreviousValuesPromise>() => T;
}

export interface StudySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudyPreviousValuesSubscription>() => T;
}

export interface StudyPreviousValues {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPreviousValuesPromise
  extends Promise<StudyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
}

export interface StudyPreviousValuesSubscription
  extends Promise<AsyncIterator<StudyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
}

export interface TherapeuticSubscriptionPayload {
  mutation: MutationType;
  node: Therapeutic;
  updatedFields: String[];
  previousValues: TherapeuticPreviousValues;
}

export interface TherapeuticSubscriptionPayloadPromise
  extends Promise<TherapeuticSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TherapeuticPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TherapeuticPreviousValuesPromise>() => T;
}

export interface TherapeuticSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TherapeuticSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TherapeuticSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TherapeuticPreviousValuesSubscription>() => T;
}

export interface TherapeuticPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TherapeuticPreviousValuesPromise
  extends Promise<TherapeuticPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TherapeuticPreviousValuesSubscription
  extends Promise<AsyncIterator<TherapeuticPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Service",
    embedded: false
  },
  {
    name: "Specialty",
    embedded: false
  },
  {
    name: "Region",
    embedded: false
  },
  {
    name: "Therapeutic",
    embedded: false
  },
  {
    name: "CompanySize",
    embedded: false
  },
  {
    name: "Phase",
    embedded: false
  },
  {
    name: "Bid",
    embedded: false
  },
  {
    name: "Study",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
