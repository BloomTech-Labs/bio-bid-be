// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  bid: (where?: BidWhereInput) => Promise<boolean>;
  company: (where?: CompanyWhereInput) => Promise<boolean>;
  study: (where?: StudyWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  bid: (where: BidWhereUniqueInput) => BidNullablePromise;
  bids: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Bid>;
  bidsConnection: (args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => BidConnectionPromise;
  company: (where: CompanyWhereUniqueInput) => CompanyNullablePromise;
  companies: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Company>;
  companiesConnection: (args?: {
    where?: CompanyWhereInput;
    orderBy?: CompanyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => CompanyConnectionPromise;
  study: (where: StudyWhereUniqueInput) => StudyNullablePromise;
  studies: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Study>;
  studiesConnection: (args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StudyConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createBid: (data: BidCreateInput) => BidPromise;
  updateBid: (args: {
    data: BidUpdateInput;
    where: BidWhereUniqueInput;
  }) => BidPromise;
  updateManyBids: (args: {
    data: BidUpdateManyMutationInput;
    where?: BidWhereInput;
  }) => BatchPayloadPromise;
  upsertBid: (args: {
    where: BidWhereUniqueInput;
    create: BidCreateInput;
    update: BidUpdateInput;
  }) => BidPromise;
  deleteBid: (where: BidWhereUniqueInput) => BidPromise;
  deleteManyBids: (where?: BidWhereInput) => BatchPayloadPromise;
  createCompany: (data: CompanyCreateInput) => CompanyPromise;
  updateCompany: (args: {
    data: CompanyUpdateInput;
    where: CompanyWhereUniqueInput;
  }) => CompanyPromise;
  updateManyCompanies: (args: {
    data: CompanyUpdateManyMutationInput;
    where?: CompanyWhereInput;
  }) => BatchPayloadPromise;
  upsertCompany: (args: {
    where: CompanyWhereUniqueInput;
    create: CompanyCreateInput;
    update: CompanyUpdateInput;
  }) => CompanyPromise;
  deleteCompany: (where: CompanyWhereUniqueInput) => CompanyPromise;
  deleteManyCompanies: (where?: CompanyWhereInput) => BatchPayloadPromise;
  createStudy: (data: StudyCreateInput) => StudyPromise;
  updateStudy: (args: {
    data: StudyUpdateInput;
    where: StudyWhereUniqueInput;
  }) => StudyPromise;
  updateManyStudies: (args: {
    data: StudyUpdateManyMutationInput;
    where?: StudyWhereInput;
  }) => BatchPayloadPromise;
  upsertStudy: (args: {
    where: StudyWhereUniqueInput;
    create: StudyCreateInput;
    update: StudyUpdateInput;
  }) => StudyPromise;
  deleteStudy: (where: StudyWhereUniqueInput) => StudyPromise;
  deleteManyStudies: (where?: StudyWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  bid: (
    where?: BidSubscriptionWhereInput
  ) => BidSubscriptionPayloadSubscription;
  company: (
    where?: CompanySubscriptionWhereInput
  ) => CompanySubscriptionPayloadSubscription;
  study: (
    where?: StudySubscriptionWhereInput
  ) => StudySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type StudyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "area_ASC"
  | "area_DESC"
  | "protocol_number_ASC"
  | "protocol_number_DESC"
  | "title_ASC"
  | "title_DESC"
  | "phase_ASC"
  | "phase_DESC"
  | "services_ASC"
  | "services_DESC"
  | "modified_date_ASC"
  | "modified_date_DESC"
  | "status_ASC"
  | "status_DESC";

export type BidOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "bid_amount_ASC"
  | "bid_amount_DESC"
  | "is_approved_ASC"
  | "is_approved_DESC";

export type CompanyOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type BidWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface StudyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  company?: Maybe<CompanyWhereInput>;
  AND?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  OR?: Maybe<StudyWhereInput[] | StudyWhereInput>;
  NOT?: Maybe<StudyWhereInput[] | StudyWhereInput>;
}

export interface CompanyWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  studies_every?: Maybe<StudyWhereInput>;
  studies_some?: Maybe<StudyWhereInput>;
  studies_none?: Maybe<StudyWhereInput>;
  bids_every?: Maybe<BidWhereInput>;
  bids_some?: Maybe<BidWhereInput>;
  bids_none?: Maybe<BidWhereInput>;
  AND?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  OR?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
  NOT?: Maybe<CompanyWhereInput[] | CompanyWhereInput>;
}

export interface BidWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  company?: Maybe<CompanyWhereInput>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  study?: Maybe<StudyWhereInput>;
  AND?: Maybe<BidWhereInput[] | BidWhereInput>;
  OR?: Maybe<BidWhereInput[] | BidWhereInput>;
  NOT?: Maybe<BidWhereInput[] | BidWhereInput>;
}

export type CompanyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export type StudyWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface BidCreateInput {
  id?: Maybe<ID_Input>;
  company: CompanyCreateOneWithoutBidsInput;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface CompanyCreateOneWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutBidsInput {
  id?: Maybe<ID_Input>;
  name: String;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
}

export interface StudyCreateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
}

export interface StudyCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
}

export interface StudyCreateOneInput {
  create?: Maybe<StudyCreateInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeInput;
  status: String;
  company: CompanyCreateOneWithoutStudiesInput;
}

export interface CompanyCreateOneWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyCreateWithoutStudiesInput {
  id?: Maybe<ID_Input>;
  name: String;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface BidCreateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
}

export interface BidCreateWithoutCompanyInput {
  id?: Maybe<ID_Input>;
  bid_amount: Float;
  is_approved?: Maybe<Boolean>;
  study: StudyCreateOneInput;
}

export interface BidUpdateInput {
  company?: Maybe<CompanyUpdateOneRequiredWithoutBidsInput>;
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface CompanyUpdateOneRequiredWithoutBidsInput {
  create?: Maybe<CompanyCreateWithoutBidsInput>;
  update?: Maybe<CompanyUpdateWithoutBidsDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutBidsInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutBidsDataInput {
  name?: Maybe<String>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
}

export interface StudyUpdateManyWithoutCompanyInput {
  create?: Maybe<
    StudyCreateWithoutCompanyInput[] | StudyCreateWithoutCompanyInput
  >;
  delete?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  connect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  set?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  disconnect?: Maybe<StudyWhereUniqueInput[] | StudyWhereUniqueInput>;
  update?: Maybe<
    | StudyUpdateWithWhereUniqueWithoutCompanyInput[]
    | StudyUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | StudyUpsertWithWhereUniqueWithoutCompanyInput[]
    | StudyUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  updateMany?: Maybe<
    StudyUpdateManyWithWhereNestedInput[] | StudyUpdateManyWithWhereNestedInput
  >;
}

export interface StudyUpdateWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  data: StudyUpdateWithoutCompanyDataInput;
}

export interface StudyUpdateWithoutCompanyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface StudyUpsertWithWhereUniqueWithoutCompanyInput {
  where: StudyWhereUniqueInput;
  update: StudyUpdateWithoutCompanyDataInput;
  create: StudyCreateWithoutCompanyInput;
}

export interface StudyScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  area?: Maybe<String>;
  area_not?: Maybe<String>;
  area_in?: Maybe<String[] | String>;
  area_not_in?: Maybe<String[] | String>;
  area_lt?: Maybe<String>;
  area_lte?: Maybe<String>;
  area_gt?: Maybe<String>;
  area_gte?: Maybe<String>;
  area_contains?: Maybe<String>;
  area_not_contains?: Maybe<String>;
  area_starts_with?: Maybe<String>;
  area_not_starts_with?: Maybe<String>;
  area_ends_with?: Maybe<String>;
  area_not_ends_with?: Maybe<String>;
  protocol_number?: Maybe<String>;
  protocol_number_not?: Maybe<String>;
  protocol_number_in?: Maybe<String[] | String>;
  protocol_number_not_in?: Maybe<String[] | String>;
  protocol_number_lt?: Maybe<String>;
  protocol_number_lte?: Maybe<String>;
  protocol_number_gt?: Maybe<String>;
  protocol_number_gte?: Maybe<String>;
  protocol_number_contains?: Maybe<String>;
  protocol_number_not_contains?: Maybe<String>;
  protocol_number_starts_with?: Maybe<String>;
  protocol_number_not_starts_with?: Maybe<String>;
  protocol_number_ends_with?: Maybe<String>;
  protocol_number_not_ends_with?: Maybe<String>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  phase?: Maybe<Int>;
  phase_not?: Maybe<Int>;
  phase_in?: Maybe<Int[] | Int>;
  phase_not_in?: Maybe<Int[] | Int>;
  phase_lt?: Maybe<Int>;
  phase_lte?: Maybe<Int>;
  phase_gt?: Maybe<Int>;
  phase_gte?: Maybe<Int>;
  services?: Maybe<Int>;
  services_not?: Maybe<Int>;
  services_in?: Maybe<Int[] | Int>;
  services_not_in?: Maybe<Int[] | Int>;
  services_lt?: Maybe<Int>;
  services_lte?: Maybe<Int>;
  services_gt?: Maybe<Int>;
  services_gte?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  modified_date_not?: Maybe<DateTimeInput>;
  modified_date_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  modified_date_lt?: Maybe<DateTimeInput>;
  modified_date_lte?: Maybe<DateTimeInput>;
  modified_date_gt?: Maybe<DateTimeInput>;
  modified_date_gte?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  status_not?: Maybe<String>;
  status_in?: Maybe<String[] | String>;
  status_not_in?: Maybe<String[] | String>;
  status_lt?: Maybe<String>;
  status_lte?: Maybe<String>;
  status_gt?: Maybe<String>;
  status_gte?: Maybe<String>;
  status_contains?: Maybe<String>;
  status_not_contains?: Maybe<String>;
  status_starts_with?: Maybe<String>;
  status_not_starts_with?: Maybe<String>;
  status_ends_with?: Maybe<String>;
  status_not_ends_with?: Maybe<String>;
  AND?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  OR?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
  NOT?: Maybe<StudyScalarWhereInput[] | StudyScalarWhereInput>;
}

export interface StudyUpdateManyWithWhereNestedInput {
  where: StudyScalarWhereInput;
  data: StudyUpdateManyDataInput;
}

export interface StudyUpdateManyDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface CompanyUpsertWithoutBidsInput {
  update: CompanyUpdateWithoutBidsDataInput;
  create: CompanyCreateWithoutBidsInput;
}

export interface StudyUpdateOneRequiredInput {
  create?: Maybe<StudyCreateInput>;
  update?: Maybe<StudyUpdateDataInput>;
  upsert?: Maybe<StudyUpsertNestedInput>;
  connect?: Maybe<StudyWhereUniqueInput>;
}

export interface StudyUpdateDataInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface CompanyUpdateOneRequiredWithoutStudiesInput {
  create?: Maybe<CompanyCreateWithoutStudiesInput>;
  update?: Maybe<CompanyUpdateWithoutStudiesDataInput>;
  upsert?: Maybe<CompanyUpsertWithoutStudiesInput>;
  connect?: Maybe<CompanyWhereUniqueInput>;
}

export interface CompanyUpdateWithoutStudiesDataInput {
  name?: Maybe<String>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface BidUpdateManyWithoutCompanyInput {
  create?: Maybe<BidCreateWithoutCompanyInput[] | BidCreateWithoutCompanyInput>;
  delete?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  connect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  set?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  disconnect?: Maybe<BidWhereUniqueInput[] | BidWhereUniqueInput>;
  update?: Maybe<
    | BidUpdateWithWhereUniqueWithoutCompanyInput[]
    | BidUpdateWithWhereUniqueWithoutCompanyInput
  >;
  upsert?: Maybe<
    | BidUpsertWithWhereUniqueWithoutCompanyInput[]
    | BidUpsertWithWhereUniqueWithoutCompanyInput
  >;
  deleteMany?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  updateMany?: Maybe<
    BidUpdateManyWithWhereNestedInput[] | BidUpdateManyWithWhereNestedInput
  >;
}

export interface BidUpdateWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  data: BidUpdateWithoutCompanyDataInput;
}

export interface BidUpdateWithoutCompanyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  study?: Maybe<StudyUpdateOneRequiredInput>;
}

export interface BidUpsertWithWhereUniqueWithoutCompanyInput {
  where: BidWhereUniqueInput;
  update: BidUpdateWithoutCompanyDataInput;
  create: BidCreateWithoutCompanyInput;
}

export interface BidScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  bid_amount?: Maybe<Float>;
  bid_amount_not?: Maybe<Float>;
  bid_amount_in?: Maybe<Float[] | Float>;
  bid_amount_not_in?: Maybe<Float[] | Float>;
  bid_amount_lt?: Maybe<Float>;
  bid_amount_lte?: Maybe<Float>;
  bid_amount_gt?: Maybe<Float>;
  bid_amount_gte?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
  is_approved_not?: Maybe<Boolean>;
  AND?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  OR?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
  NOT?: Maybe<BidScalarWhereInput[] | BidScalarWhereInput>;
}

export interface BidUpdateManyWithWhereNestedInput {
  where: BidScalarWhereInput;
  data: BidUpdateManyDataInput;
}

export interface BidUpdateManyDataInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface CompanyUpsertWithoutStudiesInput {
  update: CompanyUpdateWithoutStudiesDataInput;
  create: CompanyCreateWithoutStudiesInput;
}

export interface StudyUpsertNestedInput {
  update: StudyUpdateDataInput;
  create: StudyCreateInput;
}

export interface BidUpdateManyMutationInput {
  bid_amount?: Maybe<Float>;
  is_approved?: Maybe<Boolean>;
}

export interface CompanyCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  studies?: Maybe<StudyCreateManyWithoutCompanyInput>;
  bids?: Maybe<BidCreateManyWithoutCompanyInput>;
}

export interface CompanyUpdateInput {
  name?: Maybe<String>;
  studies?: Maybe<StudyUpdateManyWithoutCompanyInput>;
  bids?: Maybe<BidUpdateManyWithoutCompanyInput>;
}

export interface CompanyUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StudyUpdateInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
  company?: Maybe<CompanyUpdateOneRequiredWithoutStudiesInput>;
}

export interface StudyUpdateManyMutationInput {
  name?: Maybe<String>;
  area?: Maybe<String>;
  protocol_number?: Maybe<String>;
  title?: Maybe<String>;
  phase?: Maybe<Int>;
  services?: Maybe<Int>;
  modified_date?: Maybe<DateTimeInput>;
  status?: Maybe<String>;
}

export interface BidSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<BidWhereInput>;
  AND?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  OR?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
  NOT?: Maybe<BidSubscriptionWhereInput[] | BidSubscriptionWhereInput>;
}

export interface CompanySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<CompanyWhereInput>;
  AND?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  OR?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
  NOT?: Maybe<CompanySubscriptionWhereInput[] | CompanySubscriptionWhereInput>;
}

export interface StudySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StudyWhereInput>;
  AND?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  OR?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
  NOT?: Maybe<StudySubscriptionWhereInput[] | StudySubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface Bid {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPromise extends Promise<Bid>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface BidSubscription
  extends Promise<AsyncIterator<Bid>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  company: <T = CompanySubscription>() => T;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
  study: <T = StudySubscription>() => T;
}

export interface BidNullablePromise extends Promise<Bid | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  company: <T = CompanyPromise>() => T;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
  study: <T = StudyPromise>() => T;
}

export interface Company {
  id: ID_Output;
  name: String;
}

export interface CompanyPromise extends Promise<Company>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanySubscription
  extends Promise<AsyncIterator<Company>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  studies: <T = Promise<AsyncIterator<StudySubscription>>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = Promise<AsyncIterator<BidSubscription>>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface CompanyNullablePromise
  extends Promise<Company | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  studies: <T = FragmentableArray<Study>>(args?: {
    where?: StudyWhereInput;
    orderBy?: StudyOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  bids: <T = FragmentableArray<Bid>>(args?: {
    where?: BidWhereInput;
    orderBy?: BidOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Study {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPromise extends Promise<Study>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface StudySubscription
  extends Promise<AsyncIterator<Study>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
  company: <T = CompanySubscription>() => T;
}

export interface StudyNullablePromise
  extends Promise<Study | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
  company: <T = CompanyPromise>() => T;
}

export interface BidConnection {
  pageInfo: PageInfo;
  edges: BidEdge[];
}

export interface BidConnectionPromise
  extends Promise<BidConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<BidEdge>>() => T;
  aggregate: <T = AggregateBidPromise>() => T;
}

export interface BidConnectionSubscription
  extends Promise<AsyncIterator<BidConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<BidEdgeSubscription>>>() => T;
  aggregate: <T = AggregateBidSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface BidEdge {
  node: Bid;
  cursor: String;
}

export interface BidEdgePromise extends Promise<BidEdge>, Fragmentable {
  node: <T = BidPromise>() => T;
  cursor: () => Promise<String>;
}

export interface BidEdgeSubscription
  extends Promise<AsyncIterator<BidEdge>>,
    Fragmentable {
  node: <T = BidSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateBid {
  count: Int;
}

export interface AggregateBidPromise
  extends Promise<AggregateBid>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateBidSubscription
  extends Promise<AsyncIterator<AggregateBid>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface CompanyConnection {
  pageInfo: PageInfo;
  edges: CompanyEdge[];
}

export interface CompanyConnectionPromise
  extends Promise<CompanyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<CompanyEdge>>() => T;
  aggregate: <T = AggregateCompanyPromise>() => T;
}

export interface CompanyConnectionSubscription
  extends Promise<AsyncIterator<CompanyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<CompanyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateCompanySubscription>() => T;
}

export interface CompanyEdge {
  node: Company;
  cursor: String;
}

export interface CompanyEdgePromise extends Promise<CompanyEdge>, Fragmentable {
  node: <T = CompanyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface CompanyEdgeSubscription
  extends Promise<AsyncIterator<CompanyEdge>>,
    Fragmentable {
  node: <T = CompanySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateCompany {
  count: Int;
}

export interface AggregateCompanyPromise
  extends Promise<AggregateCompany>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateCompanySubscription
  extends Promise<AsyncIterator<AggregateCompany>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StudyConnection {
  pageInfo: PageInfo;
  edges: StudyEdge[];
}

export interface StudyConnectionPromise
  extends Promise<StudyConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StudyEdge>>() => T;
  aggregate: <T = AggregateStudyPromise>() => T;
}

export interface StudyConnectionSubscription
  extends Promise<AsyncIterator<StudyConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StudyEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStudySubscription>() => T;
}

export interface StudyEdge {
  node: Study;
  cursor: String;
}

export interface StudyEdgePromise extends Promise<StudyEdge>, Fragmentable {
  node: <T = StudyPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StudyEdgeSubscription
  extends Promise<AsyncIterator<StudyEdge>>,
    Fragmentable {
  node: <T = StudySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateStudy {
  count: Int;
}

export interface AggregateStudyPromise
  extends Promise<AggregateStudy>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStudySubscription
  extends Promise<AsyncIterator<AggregateStudy>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface BidSubscriptionPayload {
  mutation: MutationType;
  node: Bid;
  updatedFields: String[];
  previousValues: BidPreviousValues;
}

export interface BidSubscriptionPayloadPromise
  extends Promise<BidSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = BidPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = BidPreviousValuesPromise>() => T;
}

export interface BidSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<BidSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = BidSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = BidPreviousValuesSubscription>() => T;
}

export interface BidPreviousValues {
  id: ID_Output;
  bid_amount: Float;
  is_approved: Boolean;
}

export interface BidPreviousValuesPromise
  extends Promise<BidPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  bid_amount: () => Promise<Float>;
  is_approved: () => Promise<Boolean>;
}

export interface BidPreviousValuesSubscription
  extends Promise<AsyncIterator<BidPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  bid_amount: () => Promise<AsyncIterator<Float>>;
  is_approved: () => Promise<AsyncIterator<Boolean>>;
}

export interface CompanySubscriptionPayload {
  mutation: MutationType;
  node: Company;
  updatedFields: String[];
  previousValues: CompanyPreviousValues;
}

export interface CompanySubscriptionPayloadPromise
  extends Promise<CompanySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = CompanyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = CompanyPreviousValuesPromise>() => T;
}

export interface CompanySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<CompanySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = CompanySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = CompanyPreviousValuesSubscription>() => T;
}

export interface CompanyPreviousValues {
  id: ID_Output;
  name: String;
}

export interface CompanyPreviousValuesPromise
  extends Promise<CompanyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface CompanyPreviousValuesSubscription
  extends Promise<AsyncIterator<CompanyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface StudySubscriptionPayload {
  mutation: MutationType;
  node: Study;
  updatedFields: String[];
  previousValues: StudyPreviousValues;
}

export interface StudySubscriptionPayloadPromise
  extends Promise<StudySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StudyPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StudyPreviousValuesPromise>() => T;
}

export interface StudySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StudySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StudySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StudyPreviousValuesSubscription>() => T;
}

export interface StudyPreviousValues {
  id: ID_Output;
  name: String;
  area: String;
  protocol_number: String;
  title: String;
  phase: Int;
  services: Int;
  modified_date: DateTimeOutput;
  status: String;
}

export interface StudyPreviousValuesPromise
  extends Promise<StudyPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  area: () => Promise<String>;
  protocol_number: () => Promise<String>;
  title: () => Promise<String>;
  phase: () => Promise<Int>;
  services: () => Promise<Int>;
  modified_date: () => Promise<DateTimeOutput>;
  status: () => Promise<String>;
}

export interface StudyPreviousValuesSubscription
  extends Promise<AsyncIterator<StudyPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  area: () => Promise<AsyncIterator<String>>;
  protocol_number: () => Promise<AsyncIterator<String>>;
  title: () => Promise<AsyncIterator<String>>;
  phase: () => Promise<AsyncIterator<Int>>;
  services: () => Promise<AsyncIterator<Int>>;
  modified_date: () => Promise<AsyncIterator<DateTimeOutput>>;
  status: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Company",
    embedded: false
  },
  {
    name: "Bid",
    embedded: false
  },
  {
    name: "Study",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
